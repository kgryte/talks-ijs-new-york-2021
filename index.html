<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<title>Faster than NumPy | Talk | iJS New York, 2021</title>

	<meta name="description" content="NumPy is a foundational component of the PyData ecosystem, providing a high-performance numerical library on which countless image processing, machine learning, and data analytics tools are built in Python. Is it possible to bring the same power, performance, and robustness to JavaScript? In this talk, I’ll discuss our journey in trying to build such a library. I’ll dive deep into the weeds of performance profiling, hidden classes, cache-oblivious iteration, hardware optimization, and much more. I’ll show benchmarks showcasing how well JavaScript stacks up against the competition. And I’ll conclude by discussing where we go from here. So is it possible? Come to my talk to find out, as the answer may surprise you.">
	<meta name="author" content="Athan Reines">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<!-- Icons -->
	<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
	<link rel="manifest" href="manifest.json">
	<link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
	<meta name="theme-color" content="#ffffff">

	<!-- Stylesheets -->
	<link rel="stylesheet" href="fonts/lato/latin/lato_light.css">
	<link rel="stylesheet" href="fonts/libre-baskerville/libre_baskerville.css">
	<link rel="stylesheet" href="fonts/font-awesome/fontawesome.css">

	<link rel="stylesheet" href="node_modules/reveal.js/dist/reset.css">
	<link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css">
	<link rel="stylesheet" href="node_modules/reveal.js/dist/theme/simple.css">
	<link rel="stylesheet" href="node_modules/reveal.js-appearance/plugin/appearance/appearance.css">

	<link rel="stylesheet" href="css/highlight.css">
	<link rel="stylesheet" href="css/animate.css">
	<link rel="stylesheet" href="css/main.css">
</head>
<body>
	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">

			<section id="conf-splash" data-background-transition="slide" data-background-image="img/conf_splash.png">
				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section id="title-slide" data-transition="slide-in slide-out" data-background-image="img/splash/cheetah_1920x1280.jpg">

				<div class="background-wrap">
					<div class="background right-trapezoid-background"></div>
				</div>

				<div class="grid">
					<h1 class="fragment title"><span class="animated skidRightBig">Faster than NumPy</span></h1>
					<h2 class="fragment subtitle"><span class="animated skidRightBig">High-performance numerical computation in JavaScript</span></h2>
				</div>

				<aside class="notes">
					<p>
						Hello and welcome to my talk! I'm Athan Reines, and, today, I'll be presenting <strong>Faster than NumPy: High-performance numerical computation in JavaScript</strong>.
				</aside>
			</section>

			<section id="about-me-splash-slide" data-transition="slide-in slide-out" data-background-image="img/splash/golden_gate_bridge.jpg">

				<div class="background-wrap">
					<div class="background right-trapezoid-background"></div>
				</div>

				<div class="grid">
					<h1 class="title"><span class="animated fadeIn" data-delay="500">About me.</span></h1>
				</div>

				<aside class="notes">
					<p>
						Before we begin, I want to provide a brief overview of my background to help motivate this talk and to provide a rationale for why you should even listen to me in the first place.
					</p>
				</aside>
			</section>

			<section id="about-me-slide">

				<div class="grid">
					<div class="fragment">
						<a href="https://www.quansight.com/"><img class="animated flipInX" data-src="img/quansight_logo.png" alt="Quansight" class="undecorated" height="70%" width="70%"></a>
					</div>

					<div class="fragment">
						<a href="https://labs.quansight.org/"><img class="animated flipInX" data-src="img/quansight_labs_logo.png" alt="Quansight Labs" class="undecorated" width="70%"></a>
					</div>

					<div class="fragment">
						<a href="https://data-apis.org/"><img class="animated flipInX" data-src="img/data_apis_logo.svg" alt="Data APIs" class="undecorated" height="40%" width="40%"></a>
					</div>

					<div class="fragment">
						<a href="https://stdlib.io/docs/api/latest"><img class="animated flipInX" data-src="img/stdlib_logo_banner.svg" alt="stdlib" class="undecorated"></a>
					</div>
				</div>

				<aside class="notes">
					<p>
						I work for Quansight, a software consulting company cofounded by Travis Oliphant, the primary original author of NumPy and founding contributor to SciPy.
					</p>
					<p>
						Quansight acts as an intermediary between companies and the open source ecosystems on which those companies depend. Most of the in-house expertise, and thus the consulting work, centers around the PyData stack: NumPy, SciPy, Numba, Dask, PyData Sparse, pandas, Jupyter, conda, and others.
					</p>
					<p>
						(next fragment)
					</p>
					<p>
						Under the same corporate umbrella as Quansight is the public benefit division Quansight Labs which consists of the developers, community managers, designers, and writers who actually create and maintain the open-source technologies mentioned earlier.
					</p>
					<p>
						(next fragment)
					</p>
					<p>
						The majority of my work at Quansight is as part of the Consortium for Python Data API standards, which is a Quansight Labs led initiative to develop API standards for array and dataframe libraries within the PyData ecosystem.
					</p>
					<p>
						The Consortium brings together core maintainers from NumPy, CuPy, Dask, Torch, TensorFlow, Apache Arrow, and others in order to create hardware agnostic specifications for commonly used APIs to facilitate interoperability between array and dataframe libraries and reduce ecosystem fragmentation.
					</p>
					<p>
						(next fragment)
					</p>
					<p>
						Also, as part of my work, I am a core maintainer of the open-source project, <a href="https://stdlib.io/docs/api/latest">stdlib</a>, a standard library for JavaScript and Node.js.
					</p>
					<p>
						One of the foremost goals of stdlib is to provide the equivalent of NumPy and SciPy for <strong>numerical</strong> and <strong>scientific</strong> computation on the web and in Node.js.
					</p>
					<p>
						Most of my work on stdlib focuses on developing APIs for high-performance numerical operations on multi-dimensional arrays in JavaScript and C--the precise subject of this talk. :)
					</p>
				</aside>
			</section>

			<section id="numpy-splash-slide" data-transition="slide-in fade-out">
				<div class="background middle-stripe-background"></div>
				<div class="grid">
					<img class="animated fadeIn slow" data-delay="500" data-src="img/numpy_logo.svg" href="NumPy logo">
				</div>

				<aside class="notes">
					<p>
						Given that this is a JavaScript conference and I don't want to assume that everyone attending this talk knows Python and is familiar with the PyData numerical computing landscape, I'd like to begin our discussion by providing a high-level introduction to NumPy and array computing.
					</p>
				</aside>
			</section>

			<section id="numpy-slide" data-transition="fade-in fade-out">

				<div class="background-wrap">
					<div class="background polygon-background-1"></div>
				</div>
				<div class="grid">
					<p class="fragment fade-in-then-out">
						<span class="animated fadeIn slow" data-delay="500">
							CPU-based library for performing numerical computation on multidimensional arrays.
						</span>
					</p>
					<p class="fragment">
						<span class="animated fadeIn" data-delay="500">
							ndarray
						</span>
					</p>
				</div>

				<aside class="notes">
					<p>
						(fragment)
					</p>
					<p>
						Originally written in 2005, NumPy is a CPU-based library for performing numerical computation on multidimensional arrays.
					</p>
					<p>
						Without the assistance of a multi-process library, NumPy operations are blocking, running on a single-core and executing synchronously in sequential order.
					</p>
					<p>
						I should note that NumPy is able to leverage parallelism through SIMD operations, depending on host architecture and compilation.
					</p>
					<p>
						However--and this is relevant for later discussion--while other libraries exist to address limitations in NumPy--for example, through the use of GPUs (CuPy), GPUs/TPUs (Torch/TensorFlow), or distributed computation (Dask), NumPy does not, by itself, enjoy any inherit advantages compared to a comparable library written in JavaScript by virtue of being written in and for Python.
					</p>
					<p>
						The same issues, such as single-threading and limited host memory, that are seen as limitations in JavaScript apply equally to Python, and thus NumPy, as well.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						The fundamental building block of NumPy is the <code>ndarray</code>, which is a data structure for describing multidimensional arrays.
					</p>
					<p>
						I'll discuss the technical aspects of ndarrays throughout this talk, but, before I do, we should probably ask what is so special about multidimensional arrays.
					</p>
				</aside>
			</section>

			<section id="ndarray-use-cases-splash-slide" data-background-image="img/splash/keyboard.jpg" data-transition="fade-in fade-out" data-transition-speed="fast">

				<div class="background-wrap">
					<div class="background right-trapezoid-background"></div>
				</div>
				<div class="grid">
					<h1>Demos</h1>
				</div>

				<aside class="notes">
					<p>
						I think the best way to demonstrate why ndarrays <strong>are</strong> special is to show examples of the types of applications made possible through the use of ndarrays.
					</p>
					<p>
						So to help motivate why, in a general sense, <code>ndarrays</code> are so useful, I want to briefly digress and start with a few demos of web applications which are using <code>ndarray</code> data structures to perform various computational tasks.
					</p>
				</aside>
			</section>

			<section id="falcon-demo-slide" data-transition="fade-in fade-out">

				<iframe data-src="https://vega.github.io/falcon/flights/"></iframe>

				<aside class="notes">
					<p>
						Most of us probably have some sense that multidimensional arrays are useful in traditional numerical and scientific computing fields, even if we don't typically work with them ourselves.
					</p>
					<p>
						We've undoubtedly heard of "big data", machine learning, and artificial intelligence and probably assume that they involve working with large datasets with potentially many dimensions.
					</p>
					<p>
						At university, we may have used MATLAB and taken a data science course on Coursera or somewhere else.
					</p>
					<p>
						So my first demo should not come as too much of a surprise in that it involves working with large datasets.
					</p>
					<p>
						Currently displayed is Falcon, a library for high-performance cross-filtering of large datasets directly in the browser.
					</p>
					<p>
						What is shown is a collection of histograms visualizing different facets of a 1 million flight dataset.
					</p>
					<p>
						Internally, Falcon is using an ndarray data structure to aggregate and bin the flight data in real-time as a user interacts with the graph brushes.
					<p>
						(play with brushes and demonstrate responsiveness)
					</p>
				</aside>
			</section>

			<section id="mikola-voxel-demo-slide" data-transition="fade-in fade-out">

				<iframe data-src="https://mikolalysenko.github.io/voxel-mipmap-demo/"></iframe>

				<aside class="notes">
					<p>
						The second demo is a project by Mikola Lysenko, which provides an interactive application for demonstrating texture mapping.
					</p>
					<p>
						Internally, Mikola uses ndarrays for processing the voxel data and creating meshes.
					</p>
					<p>
						(select a few examples from the dropdown and interact with one or two of the rendered objects)
					</p>
				</aside>
			</section>

			<section id="regl-cnn-demo-slide" data-transition="fade-in fade-out">

				<iframe data-src="https://erkaman.github.io/regl-cnn/src/demo.html"></iframe>

				<aside class="notes">
					<p>
						The third demo is a project by one of the regl developers demonstrating the application of convolutional neural networks to handwritten digit recognition.
					</p>
					<p>
						Internally, this demo uses ndarrays for implementing the convolutional neural network and performing various tensor operations.
					</p>
					<p>
						(draw a few digits)
					</p>
				</aside>
			</section>

			<section id="tensorflow-pacman-demo-slide" data-transition="fade-in fade-out">

				<iframe data-src="https://storage.googleapis.com/tfjs-examples/webcam-transfer-learning/dist/index.html"></iframe>

				<aside class="notes">
					<p>
						The next demo comes from the TensorFlow.js team.
					</p>
					<p>
						In this demo--which I won't play because I'm already using my web cam for this talk--one can train a neural network directly in the browser to recognize gestures in order to control pac man as pac man navigates a maze.
					</p>
					<p>
						Similar to NumPy, ndarrays are the fundamental data structure in TensorFlow.js underpinning all the numerical computations.
					</p>
				</aside>
			</section>

			<section id="real-time-kmeans-demo-slide" data-transition="fade-in fade-out">

				<div class="image-wrapper">
					<a href="https://observablehq.com/@kgryte/stdlib-real-time-k-means-clustering"><img src="img/observable_kmeans.png"></a>
				</div>

				<aside class="notes">
					<p>
						The next demo is an Observable notebook showcasing real-time k-means clustering.
					</p>
					<p>
						(click on screenshot and pray that the notebook dependencies resolve and the notebook loads)
					</p>
					<p>
						In this notebook, ndarrays are used in the clustering of two-dimensional datasets, as the data becomes available in real-time.
					</p>
					<p>
						(scroll bottom)
					</p>
					<p>
						(try to run the simulation)
					</p>
				</aside>
			</section>

			<!-- TODO: additional demos of ndarray use cases? -->

			<section id="multidimensional-array-splash-slide" data-background-image="img/splash/multiplication_tables.jpg" data-transition="slide-in fade-out">

				<div class="background-wrap">
					<div class="background left-trapezoid-background"></div>
				</div>
				<div class="grid">
					<h1 class="animated fadeIn slow" data-delay="500">Multidimensional arrays</h1>
				</div>

				<aside class="notes">
					<p>
						Now that we've gotten a sense as to the types of applications which utilize ndarrays--data visualization, three-dimensional rendering and gaming, neural networks and artificial intelligence, and, perhaps unsurprising, more traditional machine learning tasks such as clustering and classification--let's move on to the more technical aspects of their implementation.
					</p>
					<p>
						To start, we should ask "what is a multidimensional array?"
					</p>
					<p>
						Most of us have a working understanding of multidimensional arrays and their implementation, often within the context of a list of lists (or an array of arrays in JavaScript).
					</p>
					<p>
						(next slide)
					</p>
				</aside>
			</section>

			<!-- TODO: a nice animation would be displaying a generalized depiction of array of arrays -->

			<section id="array-of-arrays-slide" data-transition="fade-in">
				<div class="grid">

					<div class="code">
						<pre><code class="language-javascript" data-trim data-line-numbers="1-5|7-9|11-13|15-17|19-24">
arr = [
	[ 1, 2, 3 ],
	[ 4, 5, 6 ],
	[ 7, 8, 9 ]
];

// Get individual item:
v = arr[1][1];
// returns 5

// Get row:
row = arr[1];
// returns [ 4, 5, 6 ]

// Get column: (!!!)
col = [ arr[0][1], arr[1][1], arr[2][1] ];
// returns [ 2, 5, 8 ]

// Column-major:
arr = [
	[ 1, [ 2, [ 3,
	  4,   5,   6,
	  7 ], 8 ], 9 ]
];
						</code></pre>
					</div>

					<div class="text">
						<p class="fragment">
							Let \( n \) be the number of elements in the innermost dimension and \( d \) be the number of dimensions.
						</p>
						<ul>
							<li class="fragment">\( O(d) \) &mdash; data access</li>
							<li class="fragment">\( O(n^{d}d) \) &mdash; traversal</li>
							<li class="fragment">\( O(n^{d}) \) &mdash; slicing</li>
							<li class="fragment">\( O(n^{d-1}) \) &mdash; extra storage requirements</li>
						</ul>
					</div>

				</div>

				<aside class="notes">
					<p>
						As an example, consider this example. Here, we have a list of three arrays, each with items.
					</p>
					<p>
						Interpreted as a two-dimensional data structure, this would comprise a 3x3 matrix, where each row is represented by a nested list/array.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						To access an individual item, we index into each dimension, dereferencing nested lists/arrays until we reached the last dimension.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						For higher-dimensional arrays, to retrieve sub-vectors, matrices, and tensors, we perform a similar procedure, except that we stop dereferencing lists once we've reached the desired dimensionality.
					</p>
					<p>
						Here, we're accessing the vector representing the second row in our matrix.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Suppose, however, that we want to access the second column in our matrix. How do we do that?
					</p>
					<p>
						Unfortunately, accessing the second column is not as simple as dereferencing a single list.
					</p>
					<p>
						Instead, we need to dereference each row, retrieve the item in the desired column, and then copy to a new array.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Of course, if we wanted to optimize for column access, we could change how we store the data, such that items belonging to the same column are stored together.
					</p>
					<p>
						However, in both scenarios, optimizing data locality for one type of data access de-optimizes the other.
					</p>
					<p>
						In general, for a list of lists/array of arrays approach to storing multidimensional data, we have the following performance characteristics.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Let \( n \) be the number of elements in the innermost dimension and \( d \) be the number of dimensions.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Data access scales linearly with the number dimensions, as we dereference pointers to nested blocks of memory.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Array traversal scales according to \( O(d n^{d}) \) and, importantly, is not guaranteed to be cache coherent.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Slicing (i.e., extracting a subarray) scales according to \( O(n^{d}) \) ).
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Lastly, storage requirements scale exponentially with the number of dimensions due to the need for intermediate arrays containing pointers.
					</p>
					<p>
						(next slide)
					</p>
				</aside>
			</section>

			<section id="implicit-arrays-splash-slide" data-background-image="img/splash/building_with_glass_window_array.jpg" data-transition="slide-in fade-out">

				<div class="background-wrap">
					<div class="background left-trapezoid-background"></div>
				</div>
				<div class="grid">
					<h1 class="animated fadeIn slow" data-delay="500">Implicit arrays</h1>
				</div>

				<aside class="notes">
					<p>
						We can address some of the theoretical shortcomings of arrays of arrays by using an <a href="https://en.wikipedia.org/wiki/Implicit_data_structure">implicit data structure</a>.
					</p>
					<p>
						An implicit data structure is one in which the position of each element conveys meaning and the relationship of that element to other elements.
					</p>
					<p>
						This is in contrast to an explicit data structure which uses pointers to describe an <emphasis>explicit</emphasis> relationship between elements (e.g., consider a linked list).
					</p>
					<p>
						(next slide)
					</p>
				</aside>
			</section>

			<!-- TODO: a nice animation would be converting an array of arrays schematic to an implicit array -->

			<section id="implicit-arrays-slide" data-transition="fade-in">
				<div class="grid">

					<div class="code">
						<pre><code class="language-javascript" data-trim data-line-numbers="1-5|7-9|11-13|15-17">
arr = [
	1, 2, 3,
	4, 5, 6,
	7, 8, 9
];

// Get individual item:
v = arr[ (1*3) + 1 ];
// returns 5

// Get row:
row = [arr[(1*3)+0], arr[(1*3)+1], arr[(1*3)+2]];
// returns [ 4, 5, 6 ]

// Get column:
col = [arr[(0*3)+1], arr[(1*3)+1], arr[(2*3)+1]];
// returns [ 2, 5, 8 ]
						</code></pre>
					</div>

					<div class="text">
						<p class="fragment">
							Let \( n \) be the number of elements in the innermost dimension, \( d \) be the number of dimensions, and \( B \) be the cache line size.
						</p>
						<ul>
							<li class="fragment">\( O(1) \) &mdash; data access</li>
							<li class="fragment">\( O(\frac{n^d}{B}) \) &mdash; traversal</li>
							<li class="fragment">\( O(\frac{n^d}{B}) \) &mdash; slicing</li>
							<li class="fragment">\( O(0) \) &mdash; extra storage requirements</li>
						</ul>
					</div>

				</div>

				<aside class="notes">
					<p>
						To convert our previous array of arrays to an implicit data structure, we do away with nested arrays and, instead, store all items in a single flat list/array.
					</p>
					<p>
						This is an implicit data structure as the ordering tells us something about the relationship of each item with the others.
					</p>
					<p>
						Notably, as we progress along the array, we traverse rows.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Beside the data layout, there are a few other key differences of this data structure compared to a list of lists/array of arrays.
					</p>
					<p>
						First, in order to access a single item, we need to perform some arithmetic.
					</p>
					<p>
						In order to get the second item in the second row, we first need to multiply the desired row number (using zero-based indexing) by the number of elements in the row and then add the desired column number (again, using zero-based indexing).
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Retrieving a row is not as simple as the list of lists implementation.
					</p>
					<p>
						We need to apply the same formula we used for accessing a single element to each element in the desired row.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						That same formula can also be applied for retrieving a column, and, thus, avoids the dereferencing overhead implicit in the list of lists/array of arrays implementation.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						In general, for an implicit array approach to storing multidimensional data, we have the following performance characteristics.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Let \( n \) be the number of elements in the innermost dimension, \( d \) be the number of dimensions, and \( B \) be the cache line size.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Data access is effectively \( O(1) \), given that performing arithmetic is generally cheaper than dereferencing memory addresses.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						For traversal, we lose a factor of \( d \), and, importantly, traversal is more likely to be cache coherent.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Similar to traversal, slicing scales according to \( O(n^d) \), being partially offset by improved data locality.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Lastly, an implicit array does not require extra storage, as we no longer need intermediate arrays containing pointers.
					</p>
					<p>
						In summary, implicit arrays have better theoretical performance guarantees than their array of arrays counterparts.
					</p>
					<p>
						(next slide)
					</p>
				</aside>
			</section>

			<!-- TODO: strided arrays: a generalization of implicit arrays; use building from below for splash -->

			<section id="ndarray-conceptual-diagram-slide" data-transition="fade-in slide-out">

				<!-- NOTE: the following are non-presentation elements used for driving the SVG animations -->
				<span class="fragment"></span>
				<span class="fragment"></span>
				<span class="fragment"></span>
				<span class="fragment"></span>
				<span class="fragment"></span>
				<span class="fragment"></span>

				<div class="grid">
					<div data-animate data-src="img/ndarray_schematic.svg">
						<!--
						{
							"setup": [
								{
									"element": "#svg-from-data-type-arrow, #svg-from-array-item-arrow, #svg-array-item-object",
									"modifier": "attr",
									"parameters": [ {"class": "fragment", "data-fragment-index": "5"} ]
								},
								{
									"element": "#svg-array-item",
									"modifier": "attr",
									"parameters": [ {"class": "fragment", "data-fragment-index": "4"} ]
								},
								{
									"element": "#svg-to-data-type-arrow, #svg-data-type-box",
									"modifier": "attr",
									"parameters": [ {"class": "fragment", "data-fragment-index": "3"} ]
								},
								{
									"element": "#svg-array-with-meta-data",
									"modifier": "attr",
									"parameters": [ {"class": "fragment", "data-fragment-index": "2"} ]
								},
								{
									"element": "#svg-array-header",
									"modifier": "attr",
									"parameters": [ {"class": "fragment", "data-fragment-index": "1"} ]
								},
								{
									"element": "#svg-array-items",
									"modifier": "attr",
									"parameters": [ {"class": "fragment", "data-fragment-index": "0"} ]
								}
							]
						}
						-->
					</div>
				</div>

				<aside class="notes">
					<p>
						(fragment)
					</p>
					<p>
						An ndarray is collection of "items", where each item has the same data type.
					</p>
					<p>
						And as a corollary, an ndarray is a <strong>homogeneous</strong> data structure, in which every item occupies a memory block of the same size and in which all blocks are interpreted in exactly the same way.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Simply having a collection of items is not sufficient, however, to perform operations on multidimensional data. We need to specify meta data describing the data location and layout.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						By associating the meta data with the collection of items is enough to fully describe and interface with an ndarray.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						How each item in the array is to be interpreted is specified by a separate data-type object (or identifier) as referenced by the ndarray meta data.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						Using the meta data, we locate and access can an individual item within the collection.
					</p>
					<p>
						(fragment)
					</p>
					<p>
						In Python (and in un-optimized JavaScript), an accessed item is "boxed", being associated with meta data and interpreted according to the previously mentioned data type object.
					</p>
					<p>
						All of this comprises the conceptual model of an ndarray.
					</p>
					<p>
						TODO: consider adding an aside that the layout need not be contiguous (i.e., can be a strided array); but probably we'll get to that.
					</p>
			</section>

			<!-- TODO: additional slides -->

			<section>

				<!-- NOTE: the following are non-presentation elements used for driving the SVG animations -->
				<span class="fragment"></span>
				<span class="fragment"></span>
				<span class="fragment"></span>

				<div data-animate data-src="img/layers_schematic.svg">
					<!--
					{
						"setup": [
							{
								"element": "#top-layer",
								"modifier": "attr",
								"parameters": [ {"class": "fragment", "data-fragment-index": "0"} ]
							},
							{
								"element": "#middle-layer",
								"modifier": "attr",
								"parameters": [ {"class": "fragment", "data-fragment-index": "1"} ]
							},
							{
								"element": "#bottom-layer",
								"modifier": "attr",
								"parameters": [ {"class": "fragment", "data-fragment-index": "2"} ]
							}
						]
					}
					-->
				</div>

				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section>
				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section id="thank-you-slide" data-transition="fade-in slide-out" data-background-image="img/splash/mountains_with_fog_1920x1280.jpg">
				<div class="grid">
					<div class="content">
						<h1><span class="animated fadeIn slow" data-delay="500">Thank you.</span></h1>
						<nav class="author-links">
							<ul class="animated fadeIn slow" data-delay="1000">
								<li>
									<a href="https://github.com/kgryte"><i class="fa fa-github"></i> Athan Reines</a>
								</li>
								<li>
									<a href="https://twitter.com/kgryte"><i class="fa fa-twitter"></i> @kgryte</a>
								</li>
								<li>
									<a href="https://twitter.com/stdlibjs"><i class="fa fa-twitter"></i> @stdlibjs</a>
								</li>
							</ul>
						</nav>
					</div>
				</div>

				<aside class="notes">
					<p>
						Thank you for attending this talk. I hope it has been informative. :)
					</p>
					<p>
						If you want to know more, you can find me on <a href="https://github.com/kgryte">GitHub</a> and Twitter.
					</p>
					<p>
						I'm happy to take any questions at this time.
					</p>
				</aside>
			</section>

		</div> <!-- /.slides -->
	</div> <!-- /.reveal -->

	<script src="node_modules/reveal.js/dist/reveal.js"></script>
	<script src="node_modules/reveal.js/plugin/notes/notes.js"></script>
	<script src="node_modules/reveal.js/plugin/highlight/highlight.js"></script>
	<script src="node_modules/reveal.js/plugin/search/search.js"></script>
	<script src="node_modules/reveal.js/plugin/math/math.js"></script>
	<script src="node_modules/reveal.js-appearance/plugin/appearance/appearance.js"></script>

	<script src="js/plugins/animate/plugin.js"></script>
	<script src="js/plugins/animate/svg.js"></script>

	<script>
		Reveal.initialize({
			// Hide the controls:
			'controls': false,

			// Show slide numbers in the speaker view:
			'showSlideNumber': 'speaker',

			// Add the current slide number to the URL hash so that reloading the page/copying the URL will return you to the same slide:
			'hash': true,

			// Only use left/right arrows to navigate slides:
			'navigationMode': 'linear',

			// Hide the presentation progress bar:
			'progress': false,

			// Disable the default layout (scaling and centering):
			'disableLayout': true,

			// Disable vertical centering:
			'center': false,

			// Specify the default transition style:
			'transition': 'slide',

			// Configure the Appearance plugin:
			'appearance': {
				// Display the elements when moving backward in the presentation:
				'hideagain': false
			},

			// Configure the plugin for rendering mathematical equations:
			'math': {
				'mathjax': '/node_modules/mathjax/es5/tex-mml-chtml.js',

				'config': 'TeX-AMS_HTML-full',

				'TeX': {
					'inlineMath': [
						[ '$', '$' ],
						[ '\\(', '\\)' ]
					]
				}
			},

			// Specify a list of plugins:
			'plugins': [
				// Syntax highlight code:
				RevealHighlight,

				// Enable speaker notes:
				RevealNotes,

				// Enable searching across slides via CTRL+SHIFT+F:
				RevealSearch,

				// Render mathematical equations:
				RevealMath,

				// Enable animations:
				Appearance,

				// Enable SVG animations:
				RevealAnimate
			]
		});
	</script>
	<script src="js/script.js"></script>
</body>
</html>
